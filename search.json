[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hamish Hartley",
    "section": "",
    "text": "Education\nMSc Advanced Computer Science - University of Strathclyde  Predicted Grade : Distinction\nBEng(Hons) Robotics, Autonomous and Interactive Systems - Heriot-Watt University  Grade : First Class Honors\n\n\nExperience\n\nAugust 2023 - January 2024, Stock replenishment, Sainsbury’s\nApril 2019 - August 2023, Chef, Lucky Pig\nDec 2018 - April 2019, FOH, National Museum of Scotland\n\n\n\nSkills\n\nPython (Django, Keras/TenorFlow,unittest, numpy, pandas) \nJava (JUnit, Swing, Maven) \nKotlin (Jetpack compose, Room API, Gradle) \nC (for embedded systems MC; Atmega328) \nLatex/Markdown (Overleaf, VScode, Quarto) \n\n\n\n\nGithub\nhttps://github.com/HamishjHartley"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Vital signs monitoring using Microstrip antenna - ADS, MATLAB \n\nAims\nThe aims of this project were to design and test a dual band microstrip antenna array for vital-signs monitoring applications. The required dual resonating frequencies being 2.45GHz and 5.8GHz respectively.\nSeveral micro strip arrays were designed in ADS keysight software; two separate 4x1 arrays which resonate at 2.45GHz and 5.8GHz respectively, which were then combined through the use of rectangular stubs into a 2x4 array which resonates at both frequencies. The combined antenna array was then fabricated on campus at Heriot-watt university and subsequently experimentally tested for its S11 and far-field parameters to evaluate it’s performance.\n\n\nDesign\n\nArray design parameters\nBoth 4x1 arrays were combined to form a 4x2 array which resonates at dual frequencies 2.45GHz and 5.8GHz. In order to combine the individual arrays, rectangular shunt stubs were used to match the characteristic impedance’s of both arrays’ respective feed lines. Stubs act as a DC open circuit and an RF short circuit corresponding to the 4/\\(\\lambda\\) length of the particular resonating frequency.\n\n\nQuarter wave transformers\nBy placing the stubs \\(\\lambda\\)/4 distance of of the opposite resonating frequency in parallel along the transmission line, (with the distances being 30.59 mm and 12.92 mm respectively) and setting length of the stubs to be \\(\\lambda\\)/4 of the corresponding resonating frequency(with the lengths of the shunt stubs being 12.92mm and 30.59mm respectively) they can be used to effectively short circuit the transmission lines leading to either the 2.45GHz array or the 5.8GHz array depending on the resonating frequency and act as an open circuit depending on the resonating frequency; this allowing current to flow to only one of the 4x1 arrays. This allows both arrays to resonate independently of each other at their intended frequencies without the need for any external components such as a switch to manually operate the array.\n \n\n\nFinal Combined Design\nShown below is the layout of the final combined antenna array design, with rectangular stubs used to match both individual arrays.\n \n\n\n\nResults\nThe simulated results shown below were obtained using ADS keysight for the S11 parameters and Momentum for the Far Field parameters. To model the complex behavior of microwave circuits, ADS uses an approach called Method of Moments (MoM). MoM extrapolates observations in order to make some prediction, and can be used to solve deterministic or eigenvalue problems.\n\n\n\nSim_results\n\n\n\n\n\nParticle Swarm Optimisation - Python \nPSO was implemented using a list containing each particle as an object. With each particle object having its own location vector, velocity vector, list of random informants and personal best; the location and velocity vector length was adaptable depending on number of dimensions, allowing flexibility of use/testing. The particle class also includes an informant update and personal best update functions for ease of readability and streamlining. A ring topology was used for the social element of the search[1], meaning each particle is only connected to its neighbours to avoid pre-mature convergence on local optima.\n\n\nPSO.py\n\n    #Particle object which contains random location and velocity \nclass Particle(object):\n    def __init__(self,index,n_informants):\n        self.index = index\n        #particles location, assigned randomly within the min and max bounds of specified function\n        self.loc = np.random.uniform(function.min_bounds, function.max_bounds,n_dimensions) \n        self.vel = np.zeros(n_dimensions) #Velocity vector (initally set to zero)\n        #initally assigning each particle randomly n_informants through an index in range of swarmsize\n        self.informants = np.random.randint(0,swarmsize-1,n_informants) \n        #sets the particles inital personal best as inital location\n        self.pbest = self.loc\n        \n    #updates the particle's informants(used each iteration)\n    def update_informants(self): \n        self.informants = np.random.randint(0,swarmsize-1,n_informants)\n\n    #updates each particles personal best\n    def update_pbest(self):\n        if (ideal - self.loc) &lt; (ideal - self.pbest):\n            self.pbest = self.loc\n\n\n\nPSO.py\n\n#Swarm list to contain these particle objects\nswarm = []\n\n#Populating swarm list with particle objects\nfor i in range(swarmsize):\n    swarm.append(Particle(i,n_informants))\n\n\n\nPSO.py\n\n#finds global best value by creating a list of fitnesses for each particle, compares them all\ndef global_best(): \n\n#finds informant best value by creating a list of fitnesses for each particle, compares them all\ndef informant_best(x):\n\n#velocity update calculation, which takes personal best, informant best and global best into consideration\nswarm[j].vel[n] =alpha*swarm[j].vel[n] + b*(swarm[j].pbest[n] - xi)+c*(swarm[i_best].loc[n]-xi) +d*(swarm[best].loc[n]-xi)\n\n#updating each particles location with updated velocity\nswarm[k].loc = swarm[k].loc + E* swarm[k].vel\n\n\n\nMulti-thread GUI Traffic road system simulation - Java \n\n\nChess engine - Python \n\n\nAutomated Plant watering system - C"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi my name’s Hamish, i’m a 23 years old and Glasgow based.  I’m currently enrolled on the MSc Advanced Computer Science course at the University of Strathclyde."
  }
]